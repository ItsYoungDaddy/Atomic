/*
 * This file is part of the atomic client distribution.
 * Copyright (c) 2021. 0x150 and contributors
 */

package me.zeroX150.atomic.feature.gui.screen;

import me.zeroX150.atomic.Atomic;
import me.zeroX150.atomic.feature.ItemExploits;
import me.zeroX150.atomic.feature.gui.widget.ItemExploitConfigRenderer;
import me.zeroX150.atomic.helper.Transitions;
import me.zeroX150.atomic.helper.render.Renderer;
import net.minecraft.client.gui.Element;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.ClickableWidget;
import net.minecraft.client.gui.widget.TextFieldWidget;
import net.minecraft.client.util.math.MatrixStack;
import net.minecraft.text.Text;
import net.minecraft.util.math.MathHelper;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;

public class ItemExploitsScreen extends Screen implements FastTickable {
    final List<ClickableWidget> elements = new ArrayList<>();
    final Screen parent;
    int i = -1;
    double scroll = 0;
    double renderScroll = 0;
    double animationProg = 0;
    boolean close = false;
    ItemExploitConfigRenderer configRenderer;
    String searchTerm = "";

    public ItemExploitsScreen(Screen parent) {
        super(Text.of(""));
        this.parent = parent;
    }

    @Override
    public void onFastTick() {
        renderScroll = Transitions.transition(renderScroll, scroll, 7, 0.002);
        double a = 0.02;
        if (close) {
            a *= -1;
            i = -1;
        }
        animationProg += a;
        animationProg = MathHelper.clamp(animationProg, 0, 1);
    }

    @Override
    public boolean mouseScrolled(double mouseX, double mouseY, double amount) {
        scroll -= amount * 20;
        if (scroll < 0) scroll = 0;
        return super.mouseScrolled(mouseX, mouseY, amount);
    }

    @Override
    public void onClose() {
        close = true;
    }

    void renderElement(ClickableWidget e) {
        elements.add(e);
    }

    @Override
    protected void init() {
        close = false;
        animationProg = 0;
        super.init();
    }

    @Override
    public void tick() {
        super.tick();
        if (configRenderer != null) configRenderer.tick();
    }

    @Override
    public void render(MatrixStack matrices, int mouseX, int mouseY, float delta) {
        if (animationProg == 0 && close) {
            Atomic.client.setScreen(parent);
        }
        matrices.push();
        parent.render(matrices, 0, 0, delta);
        this.clearChildren();
        for (ClickableWidget element : elements) {
            this.addDrawableChild(element);
        }
        elements.clear();
        double animProgInterRev = 1 - Transitions.easeOutBack(animationProg);
        matrices.push();
        matrices.scale((float) (1 - animProgInterRev), 1, 1);
        renderBackground(matrices);
        String t = searchTerm.isEmpty() ? "Press any key to search" : "Search (esc to clear): " + searchTerm;
        float tw = Atomic.monoFontRenderer.getStringWidth(t);
        float rX = width - tw - 5;
        float rY = height - 14;
        Atomic.monoFontRenderer.drawString(matrices, t, rX, rY, 0xFFFFFF);
        matrices.pop();
        ItemExploits.ItemExploit[] v = ItemExploits.ItemExploit.values();
        int yOff = 5;
        int w = 150;
        matrices.push();
        matrices.translate(0, -renderScroll, 0);
        matrices.translate(animProgInterRev * (-w - 5), 0, 0);
        for (int i1 = 0; i1 < v.length; i1++) {
            ItemExploits.ItemExploit e = v[i1];
            if (!searchTerm.isEmpty() && !e.getName().toLowerCase().startsWith(searchTerm.toLowerCase())) continue;
            int bw = 140;
            String split = e.getGenerator().getDescription();
            List<String> splitContent = new ArrayList<>();
            StringBuilder line = new StringBuilder();
            for (String c : split.split(" +")) {
                if (Atomic.monoFontRenderer.getStringWidth(line + " " + c) >= (w - 10)) {
                    splitContent.add(line.toString());
                    line = new StringBuilder();
                }
                line.append(c).append(" ");
            }
            splitContent.add(line.toString());
            // top margin, title, split description, desc -> button margin, button, button -> end margin
            // margin = 5, mostly
            // font size = 9 + 1 to account for margins
            int h = 5 + 10 + (splitContent.size() * 10) + 5 + 20 + 5;
            Renderer.R2D.fill(matrices, new Color(20, 20, 28, 210), 5, yOff, 5 + w, yOff + h);
            Atomic.fontRenderer.drawCenteredString(matrices, e.getName(), 5 + w / 2f, yOff + 5, 0xFFFFFF);
            int yOff1 = 10;
            for (String s : splitContent) {
                s = s.trim();
                Atomic.monoFontRenderer.drawCenteredString(matrices, s, 5 + w / 2f, yOff + 5 + yOff1, 0xFFBBBBBB);
                yOff1 += 10;
            }
            int finalI = i1;
            ButtonWidget selector = new ButtonWidget(5 + (w / 2) - (bw / 2), yOff + h - 25, bw, 20, Text.of("Select"), button -> {
                i = finalI;
                configRenderer = new ItemExploitConfigRenderer(ItemExploits.ItemExploit.values()[i], w + 10, 15);
            });
            renderElement(selector);
            yOff += h + 5;
        }
        if (i != -1) {
            matrices.pop();
            ItemExploits.ItemExploit selected = v[i];
            Atomic.fontRenderer.drawCenteredString(matrices, selected.getName() + " options", w + 10 + (150 / 2f), 5, 0xFFFFFF);
            if (configRenderer != null) configRenderer.render(matrices, mouseX, mouseY, delta);
            matrices.push();
            matrices.translate(w + 10 + 150 + 20, 0, 0);
            selected.getGenerator().renderPreview(matrices, this.width - (w + 10 + 150 + 10), this.height);
        }
        matrices.pop();
        matrices.push();
        matrices.translate(0, -renderScroll, 0);
        matrices.translate(animProgInterRev * (-w - 5), 0, 0);
        if (scroll > yOff - height) scroll = yOff - height;
        mouseY += renderScroll;
        super.render(matrices, mouseX, mouseY, delta);
        matrices.pop();
        Element focussed = this.getFocused();
        for (ClickableWidget element : elements) {
            if (element instanceof TextFieldWidget wid) {
                wid.setTextFieldFocused(focussed != null && focussed.equals(element));
            }
        }
    }

    @Override
    public boolean mouseClicked(double mouseX, double mouseY, int button) {
        if (configRenderer != null) configRenderer.mouseClicked(mouseX, mouseY, button);
        mouseY += renderScroll;
        return super.mouseClicked(mouseX, mouseY, button);
    }

    @Override
    public boolean charTyped(char chr, int modifiers) {
        boolean cancel = false;
        if (configRenderer != null) cancel = configRenderer.charTyped(chr, modifiers);
        if (!cancel) {
            searchTerm += chr;
        }
        return super.charTyped(chr, modifiers);
    }

    @Override
    public boolean keyPressed(int keyCode, int scanCode, int modifiers) {
        if (configRenderer != null) configRenderer.keyPressed(keyCode, scanCode, modifiers);
        if (keyCode == 256 && !searchTerm.isEmpty()) {
            searchTerm = "";
            mouseScrolled(0, 0, 0);
            return true;
        }
        if (keyCode == 32) {
            return true;
        }
        return super.keyPressed(keyCode, scanCode, modifiers);
    }

    @Override
    public boolean keyReleased(int keyCode, int scanCode, int modifiers) {
        if (configRenderer != null) configRenderer.keyReleased(keyCode, scanCode, modifiers);
        return super.keyReleased(keyCode, scanCode, modifiers);
    }

    @Override
    public boolean isPauseScreen() {
        return false;
    }
}
